// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/giantswarm/graph/ent/githubissue"
	"github.com/giantswarm/graph/ent/githubuser"
	"github.com/giantswarm/graph/ent/person"
	"github.com/giantswarm/graph/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCluster     = "Cluster"
	TypeGitHubIssue = "GitHubIssue"
	TypeGitHubUser  = "GitHubUser"
	TypePerson      = "Person"
)

// ClusterMutation represents an operation that mutates the Cluster nodes in the graph.
type ClusterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Cluster, error)
	predicates    []predicate.Cluster
}

var _ ent.Mutation = (*ClusterMutation)(nil)

// clusterOption allows management of the mutation configuration using functional options.
type clusterOption func(*ClusterMutation)

// newClusterMutation creates new mutation for the Cluster entity.
func newClusterMutation(c config, op Op, opts ...clusterOption) *ClusterMutation {
	m := &ClusterMutation{
		config:        c,
		op:            op,
		typ:           TypeCluster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClusterID sets the ID field of the mutation.
func withClusterID(id int) clusterOption {
	return func(m *ClusterMutation) {
		var (
			err   error
			once  sync.Once
			value *Cluster
		)
		m.oldValue = func(ctx context.Context) (*Cluster, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cluster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCluster sets the old Cluster of the mutation.
func withCluster(node *Cluster) clusterOption {
	return func(m *ClusterMutation) {
		m.oldValue = func(context.Context) (*Cluster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClusterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClusterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClusterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Where appends a list predicates to the ClusterMutation builder.
func (m *ClusterMutation) Where(ps ...predicate.Cluster) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClusterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cluster).
func (m *ClusterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClusterMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClusterMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClusterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Cluster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClusterMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cluster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClusterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClusterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClusterMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Cluster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClusterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClusterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClusterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cluster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClusterMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Cluster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClusterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClusterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClusterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClusterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClusterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClusterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClusterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cluster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClusterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cluster edge %s", name)
}

// GitHubIssueMutation represents an operation that mutates the GitHubIssue nodes in the graph.
type GitHubIssueMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	number             *int
	addnumber          *int
	title              *string
	body               *string
	html_url           *string
	state              *githubissue.State
	locked             *bool
	active_lock_reason *string
	comments_count     *int
	addcomments_count  *int
	created_at         *string
	updated_at         *string
	closed_at          *string
	author_association *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*GitHubIssue, error)
	predicates         []predicate.GitHubIssue
}

var _ ent.Mutation = (*GitHubIssueMutation)(nil)

// githubissueOption allows management of the mutation configuration using functional options.
type githubissueOption func(*GitHubIssueMutation)

// newGitHubIssueMutation creates new mutation for the GitHubIssue entity.
func newGitHubIssueMutation(c config, op Op, opts ...githubissueOption) *GitHubIssueMutation {
	m := &GitHubIssueMutation{
		config:        c,
		op:            op,
		typ:           TypeGitHubIssue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGitHubIssueID sets the ID field of the mutation.
func withGitHubIssueID(id int) githubissueOption {
	return func(m *GitHubIssueMutation) {
		var (
			err   error
			once  sync.Once
			value *GitHubIssue
		)
		m.oldValue = func(ctx context.Context) (*GitHubIssue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GitHubIssue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGitHubIssue sets the old GitHubIssue of the mutation.
func withGitHubIssue(node *GitHubIssue) githubissueOption {
	return func(m *GitHubIssueMutation) {
		m.oldValue = func(context.Context) (*GitHubIssue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GitHubIssueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GitHubIssueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GitHubIssue entities.
func (m *GitHubIssueMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GitHubIssueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNumber sets the "number" field.
func (m *GitHubIssueMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *GitHubIssueMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *GitHubIssueMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *GitHubIssueMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *GitHubIssueMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetTitle sets the "title" field.
func (m *GitHubIssueMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GitHubIssueMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *GitHubIssueMutation) ResetTitle() {
	m.title = nil
}

// SetBody sets the "body" field.
func (m *GitHubIssueMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *GitHubIssueMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *GitHubIssueMutation) ResetBody() {
	m.body = nil
}

// SetHTMLURL sets the "html_url" field.
func (m *GitHubIssueMutation) SetHTMLURL(s string) {
	m.html_url = &s
}

// HTMLURL returns the value of the "html_url" field in the mutation.
func (m *GitHubIssueMutation) HTMLURL() (r string, exists bool) {
	v := m.html_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLURL returns the old "html_url" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldHTMLURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHTMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHTMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLURL: %w", err)
	}
	return oldValue.HTMLURL, nil
}

// ResetHTMLURL resets all changes to the "html_url" field.
func (m *GitHubIssueMutation) ResetHTMLURL() {
	m.html_url = nil
}

// SetState sets the "state" field.
func (m *GitHubIssueMutation) SetState(gi githubissue.State) {
	m.state = &gi
}

// State returns the value of the "state" field in the mutation.
func (m *GitHubIssueMutation) State() (r githubissue.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldState(ctx context.Context) (v githubissue.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *GitHubIssueMutation) ResetState() {
	m.state = nil
}

// SetLocked sets the "locked" field.
func (m *GitHubIssueMutation) SetLocked(b bool) {
	m.locked = &b
}

// Locked returns the value of the "locked" field in the mutation.
func (m *GitHubIssueMutation) Locked() (r bool, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldLocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ResetLocked resets all changes to the "locked" field.
func (m *GitHubIssueMutation) ResetLocked() {
	m.locked = nil
}

// SetActiveLockReason sets the "active_lock_reason" field.
func (m *GitHubIssueMutation) SetActiveLockReason(s string) {
	m.active_lock_reason = &s
}

// ActiveLockReason returns the value of the "active_lock_reason" field in the mutation.
func (m *GitHubIssueMutation) ActiveLockReason() (r string, exists bool) {
	v := m.active_lock_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveLockReason returns the old "active_lock_reason" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldActiveLockReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActiveLockReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActiveLockReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveLockReason: %w", err)
	}
	return oldValue.ActiveLockReason, nil
}

// ResetActiveLockReason resets all changes to the "active_lock_reason" field.
func (m *GitHubIssueMutation) ResetActiveLockReason() {
	m.active_lock_reason = nil
}

// SetCommentsCount sets the "comments_count" field.
func (m *GitHubIssueMutation) SetCommentsCount(i int) {
	m.comments_count = &i
	m.addcomments_count = nil
}

// CommentsCount returns the value of the "comments_count" field in the mutation.
func (m *GitHubIssueMutation) CommentsCount() (r int, exists bool) {
	v := m.comments_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentsCount returns the old "comments_count" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldCommentsCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommentsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommentsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentsCount: %w", err)
	}
	return oldValue.CommentsCount, nil
}

// AddCommentsCount adds i to the "comments_count" field.
func (m *GitHubIssueMutation) AddCommentsCount(i int) {
	if m.addcomments_count != nil {
		*m.addcomments_count += i
	} else {
		m.addcomments_count = &i
	}
}

// AddedCommentsCount returns the value that was added to the "comments_count" field in this mutation.
func (m *GitHubIssueMutation) AddedCommentsCount() (r int, exists bool) {
	v := m.addcomments_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentsCount resets all changes to the "comments_count" field.
func (m *GitHubIssueMutation) ResetCommentsCount() {
	m.comments_count = nil
	m.addcomments_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GitHubIssueMutation) SetCreatedAt(s string) {
	m.created_at = &s
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GitHubIssueMutation) CreatedAt() (r string, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldCreatedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GitHubIssueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GitHubIssueMutation) SetUpdatedAt(s string) {
	m.updated_at = &s
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GitHubIssueMutation) UpdatedAt() (r string, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldUpdatedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GitHubIssueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *GitHubIssueMutation) SetClosedAt(s string) {
	m.closed_at = &s
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *GitHubIssueMutation) ClosedAt() (r string, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldClosedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *GitHubIssueMutation) ResetClosedAt() {
	m.closed_at = nil
}

// SetAuthorAssociation sets the "author_association" field.
func (m *GitHubIssueMutation) SetAuthorAssociation(s string) {
	m.author_association = &s
}

// AuthorAssociation returns the value of the "author_association" field in the mutation.
func (m *GitHubIssueMutation) AuthorAssociation() (r string, exists bool) {
	v := m.author_association
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorAssociation returns the old "author_association" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldAuthorAssociation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthorAssociation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthorAssociation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorAssociation: %w", err)
	}
	return oldValue.AuthorAssociation, nil
}

// ResetAuthorAssociation resets all changes to the "author_association" field.
func (m *GitHubIssueMutation) ResetAuthorAssociation() {
	m.author_association = nil
}

// Where appends a list predicates to the GitHubIssueMutation builder.
func (m *GitHubIssueMutation) Where(ps ...predicate.GitHubIssue) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GitHubIssueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GitHubIssue).
func (m *GitHubIssueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GitHubIssueMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.number != nil {
		fields = append(fields, githubissue.FieldNumber)
	}
	if m.title != nil {
		fields = append(fields, githubissue.FieldTitle)
	}
	if m.body != nil {
		fields = append(fields, githubissue.FieldBody)
	}
	if m.html_url != nil {
		fields = append(fields, githubissue.FieldHTMLURL)
	}
	if m.state != nil {
		fields = append(fields, githubissue.FieldState)
	}
	if m.locked != nil {
		fields = append(fields, githubissue.FieldLocked)
	}
	if m.active_lock_reason != nil {
		fields = append(fields, githubissue.FieldActiveLockReason)
	}
	if m.comments_count != nil {
		fields = append(fields, githubissue.FieldCommentsCount)
	}
	if m.created_at != nil {
		fields = append(fields, githubissue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, githubissue.FieldUpdatedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, githubissue.FieldClosedAt)
	}
	if m.author_association != nil {
		fields = append(fields, githubissue.FieldAuthorAssociation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GitHubIssueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case githubissue.FieldNumber:
		return m.Number()
	case githubissue.FieldTitle:
		return m.Title()
	case githubissue.FieldBody:
		return m.Body()
	case githubissue.FieldHTMLURL:
		return m.HTMLURL()
	case githubissue.FieldState:
		return m.State()
	case githubissue.FieldLocked:
		return m.Locked()
	case githubissue.FieldActiveLockReason:
		return m.ActiveLockReason()
	case githubissue.FieldCommentsCount:
		return m.CommentsCount()
	case githubissue.FieldCreatedAt:
		return m.CreatedAt()
	case githubissue.FieldUpdatedAt:
		return m.UpdatedAt()
	case githubissue.FieldClosedAt:
		return m.ClosedAt()
	case githubissue.FieldAuthorAssociation:
		return m.AuthorAssociation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GitHubIssueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case githubissue.FieldNumber:
		return m.OldNumber(ctx)
	case githubissue.FieldTitle:
		return m.OldTitle(ctx)
	case githubissue.FieldBody:
		return m.OldBody(ctx)
	case githubissue.FieldHTMLURL:
		return m.OldHTMLURL(ctx)
	case githubissue.FieldState:
		return m.OldState(ctx)
	case githubissue.FieldLocked:
		return m.OldLocked(ctx)
	case githubissue.FieldActiveLockReason:
		return m.OldActiveLockReason(ctx)
	case githubissue.FieldCommentsCount:
		return m.OldCommentsCount(ctx)
	case githubissue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case githubissue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case githubissue.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case githubissue.FieldAuthorAssociation:
		return m.OldAuthorAssociation(ctx)
	}
	return nil, fmt.Errorf("unknown GitHubIssue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitHubIssueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case githubissue.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case githubissue.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case githubissue.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case githubissue.FieldHTMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLURL(v)
		return nil
	case githubissue.FieldState:
		v, ok := value.(githubissue.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case githubissue.FieldLocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case githubissue.FieldActiveLockReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveLockReason(v)
		return nil
	case githubissue.FieldCommentsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentsCount(v)
		return nil
	case githubissue.FieldCreatedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case githubissue.FieldUpdatedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case githubissue.FieldClosedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case githubissue.FieldAuthorAssociation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorAssociation(v)
		return nil
	}
	return fmt.Errorf("unknown GitHubIssue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GitHubIssueMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, githubissue.FieldNumber)
	}
	if m.addcomments_count != nil {
		fields = append(fields, githubissue.FieldCommentsCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GitHubIssueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case githubissue.FieldNumber:
		return m.AddedNumber()
	case githubissue.FieldCommentsCount:
		return m.AddedCommentsCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitHubIssueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case githubissue.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case githubissue.FieldCommentsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentsCount(v)
		return nil
	}
	return fmt.Errorf("unknown GitHubIssue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GitHubIssueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GitHubIssueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GitHubIssueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GitHubIssue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GitHubIssueMutation) ResetField(name string) error {
	switch name {
	case githubissue.FieldNumber:
		m.ResetNumber()
		return nil
	case githubissue.FieldTitle:
		m.ResetTitle()
		return nil
	case githubissue.FieldBody:
		m.ResetBody()
		return nil
	case githubissue.FieldHTMLURL:
		m.ResetHTMLURL()
		return nil
	case githubissue.FieldState:
		m.ResetState()
		return nil
	case githubissue.FieldLocked:
		m.ResetLocked()
		return nil
	case githubissue.FieldActiveLockReason:
		m.ResetActiveLockReason()
		return nil
	case githubissue.FieldCommentsCount:
		m.ResetCommentsCount()
		return nil
	case githubissue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case githubissue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case githubissue.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case githubissue.FieldAuthorAssociation:
		m.ResetAuthorAssociation()
		return nil
	}
	return fmt.Errorf("unknown GitHubIssue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GitHubIssueMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GitHubIssueMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GitHubIssueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GitHubIssueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GitHubIssueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GitHubIssueMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GitHubIssueMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GitHubIssue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GitHubIssueMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GitHubIssue edge %s", name)
}

// GitHubUserMutation represents an operation that mutates the GitHubUser nodes in the graph.
type GitHubUserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	login         *string
	email         *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GitHubUser, error)
	predicates    []predicate.GitHubUser
}

var _ ent.Mutation = (*GitHubUserMutation)(nil)

// githubuserOption allows management of the mutation configuration using functional options.
type githubuserOption func(*GitHubUserMutation)

// newGitHubUserMutation creates new mutation for the GitHubUser entity.
func newGitHubUserMutation(c config, op Op, opts ...githubuserOption) *GitHubUserMutation {
	m := &GitHubUserMutation{
		config:        c,
		op:            op,
		typ:           TypeGitHubUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGitHubUserID sets the ID field of the mutation.
func withGitHubUserID(id int) githubuserOption {
	return func(m *GitHubUserMutation) {
		var (
			err   error
			once  sync.Once
			value *GitHubUser
		)
		m.oldValue = func(ctx context.Context) (*GitHubUser, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GitHubUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGitHubUser sets the old GitHubUser of the mutation.
func withGitHubUser(node *GitHubUser) githubuserOption {
	return func(m *GitHubUserMutation) {
		m.oldValue = func(context.Context) (*GitHubUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GitHubUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GitHubUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GitHubUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLogin sets the "login" field.
func (m *GitHubUserMutation) SetLogin(s string) {
	m.login = &s
}

// Login returns the value of the "login" field in the mutation.
func (m *GitHubUserMutation) Login() (r string, exists bool) {
	v := m.login
	if v == nil {
		return
	}
	return *v, true
}

// OldLogin returns the old "login" field's value of the GitHubUser entity.
// If the GitHubUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubUserMutation) OldLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogin: %w", err)
	}
	return oldValue.Login, nil
}

// ResetLogin resets all changes to the "login" field.
func (m *GitHubUserMutation) ResetLogin() {
	m.login = nil
}

// SetEmail sets the "email" field.
func (m *GitHubUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *GitHubUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the GitHubUser entity.
// If the GitHubUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *GitHubUserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *GitHubUserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GitHubUserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GitHubUser entity.
// If the GitHubUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubUserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GitHubUserMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the GitHubUserMutation builder.
func (m *GitHubUserMutation) Where(ps ...predicate.GitHubUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GitHubUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GitHubUser).
func (m *GitHubUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GitHubUserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.login != nil {
		fields = append(fields, githubuser.FieldLogin)
	}
	if m.email != nil {
		fields = append(fields, githubuser.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, githubuser.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GitHubUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case githubuser.FieldLogin:
		return m.Login()
	case githubuser.FieldEmail:
		return m.Email()
	case githubuser.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GitHubUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case githubuser.FieldLogin:
		return m.OldLogin(ctx)
	case githubuser.FieldEmail:
		return m.OldEmail(ctx)
	case githubuser.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown GitHubUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitHubUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case githubuser.FieldLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogin(v)
		return nil
	case githubuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case githubuser.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown GitHubUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GitHubUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GitHubUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitHubUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GitHubUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GitHubUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GitHubUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GitHubUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GitHubUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GitHubUserMutation) ResetField(name string) error {
	switch name {
	case githubuser.FieldLogin:
		m.ResetLogin()
		return nil
	case githubuser.FieldEmail:
		m.ResetEmail()
		return nil
	case githubuser.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown GitHubUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GitHubUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GitHubUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GitHubUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GitHubUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GitHubUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GitHubUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GitHubUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GitHubUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GitHubUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GitHubUser edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	email                *string
	name                 *string
	isGiantSwarmEmployee *bool
	clearedFields        map[string]struct{}
	gitHubAccount        *int
	clearedgitHubAccount bool
	done                 bool
	oldValue             func(context.Context) (*Person, error)
	predicates           []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id int) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *PersonMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PersonMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *PersonMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *PersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonMutation) ResetName() {
	m.name = nil
}

// SetIsGiantSwarmEmployee sets the "isGiantSwarmEmployee" field.
func (m *PersonMutation) SetIsGiantSwarmEmployee(b bool) {
	m.isGiantSwarmEmployee = &b
}

// IsGiantSwarmEmployee returns the value of the "isGiantSwarmEmployee" field in the mutation.
func (m *PersonMutation) IsGiantSwarmEmployee() (r bool, exists bool) {
	v := m.isGiantSwarmEmployee
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGiantSwarmEmployee returns the old "isGiantSwarmEmployee" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIsGiantSwarmEmployee(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsGiantSwarmEmployee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsGiantSwarmEmployee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGiantSwarmEmployee: %w", err)
	}
	return oldValue.IsGiantSwarmEmployee, nil
}

// ResetIsGiantSwarmEmployee resets all changes to the "isGiantSwarmEmployee" field.
func (m *PersonMutation) ResetIsGiantSwarmEmployee() {
	m.isGiantSwarmEmployee = nil
}

// SetGitHubAccountID sets the "gitHubAccount" edge to the GitHubUser entity by id.
func (m *PersonMutation) SetGitHubAccountID(id int) {
	m.gitHubAccount = &id
}

// ClearGitHubAccount clears the "gitHubAccount" edge to the GitHubUser entity.
func (m *PersonMutation) ClearGitHubAccount() {
	m.clearedgitHubAccount = true
}

// GitHubAccountCleared reports if the "gitHubAccount" edge to the GitHubUser entity was cleared.
func (m *PersonMutation) GitHubAccountCleared() bool {
	return m.clearedgitHubAccount
}

// GitHubAccountID returns the "gitHubAccount" edge ID in the mutation.
func (m *PersonMutation) GitHubAccountID() (id int, exists bool) {
	if m.gitHubAccount != nil {
		return *m.gitHubAccount, true
	}
	return
}

// GitHubAccountIDs returns the "gitHubAccount" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GitHubAccountID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) GitHubAccountIDs() (ids []int) {
	if id := m.gitHubAccount; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGitHubAccount resets all changes to the "gitHubAccount" edge.
func (m *PersonMutation) ResetGitHubAccount() {
	m.gitHubAccount = nil
	m.clearedgitHubAccount = false
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, person.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, person.FieldName)
	}
	if m.isGiantSwarmEmployee != nil {
		fields = append(fields, person.FieldIsGiantSwarmEmployee)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldEmail:
		return m.Email()
	case person.FieldName:
		return m.Name()
	case person.FieldIsGiantSwarmEmployee:
		return m.IsGiantSwarmEmployee()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldEmail:
		return m.OldEmail(ctx)
	case person.FieldName:
		return m.OldName(ctx)
	case person.FieldIsGiantSwarmEmployee:
		return m.OldIsGiantSwarmEmployee(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case person.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case person.FieldIsGiantSwarmEmployee:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGiantSwarmEmployee(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldEmail:
		m.ResetEmail()
		return nil
	case person.FieldName:
		m.ResetName()
		return nil
	case person.FieldIsGiantSwarmEmployee:
		m.ResetIsGiantSwarmEmployee()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.gitHubAccount != nil {
		edges = append(edges, person.EdgeGitHubAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeGitHubAccount:
		if id := m.gitHubAccount; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgitHubAccount {
		edges = append(edges, person.EdgeGitHubAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeGitHubAccount:
		return m.clearedgitHubAccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	case person.EdgeGitHubAccount:
		m.ClearGitHubAccount()
		return nil
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeGitHubAccount:
		m.ResetGitHubAccount()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

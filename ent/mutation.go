// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/giantswarm/graph/ent/githubissue"
	"github.com/giantswarm/graph/ent/githubuser"
	"github.com/giantswarm/graph/ent/person"
	"github.com/giantswarm/graph/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCluster     = "Cluster"
	TypeGitHubIssue = "GitHubIssue"
	TypeGitHubUser  = "GitHubUser"
	TypePerson      = "Person"
)

// ClusterMutation represents an operation that mutates the Cluster nodes in the graph.
type ClusterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Cluster, error)
	predicates    []predicate.Cluster
}

var _ ent.Mutation = (*ClusterMutation)(nil)

// clusterOption allows management of the mutation configuration using functional options.
type clusterOption func(*ClusterMutation)

// newClusterMutation creates new mutation for the Cluster entity.
func newClusterMutation(c config, op Op, opts ...clusterOption) *ClusterMutation {
	m := &ClusterMutation{
		config:        c,
		op:            op,
		typ:           TypeCluster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClusterID sets the ID field of the mutation.
func withClusterID(id int) clusterOption {
	return func(m *ClusterMutation) {
		var (
			err   error
			once  sync.Once
			value *Cluster
		)
		m.oldValue = func(ctx context.Context) (*Cluster, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cluster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCluster sets the old Cluster of the mutation.
func withCluster(node *Cluster) clusterOption {
	return func(m *ClusterMutation) {
		m.oldValue = func(context.Context) (*Cluster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClusterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClusterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClusterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Where appends a list predicates to the ClusterMutation builder.
func (m *ClusterMutation) Where(ps ...predicate.Cluster) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClusterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cluster).
func (m *ClusterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClusterMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClusterMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClusterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Cluster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClusterMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cluster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClusterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClusterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClusterMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Cluster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClusterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClusterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClusterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cluster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClusterMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Cluster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClusterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClusterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClusterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClusterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClusterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClusterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClusterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cluster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClusterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cluster edge %s", name)
}

// GitHubIssueMutation represents an operation that mutates the GitHubIssue nodes in the graph.
type GitHubIssueMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	github_id          *int
	addgithub_id       *int
	number             *int
	addnumber          *int
	title              *string
	body               *string
	html_url           *string
	state              *githubissue.State
	locked             *bool
	active_lock_reason *string
	comments_count     *int
	addcomments_count  *int
	created_at         *string
	updated_at         *string
	closed_at          *string
	author_association *string
	clearedFields      map[string]struct{}
	assignees          map[int]struct{}
	removedassignees   map[int]struct{}
	clearedassignees   bool
	author             *int
	clearedauthor      bool
	closed_by          *int
	clearedclosed_by   bool
	done               bool
	oldValue           func(context.Context) (*GitHubIssue, error)
	predicates         []predicate.GitHubIssue
}

var _ ent.Mutation = (*GitHubIssueMutation)(nil)

// githubissueOption allows management of the mutation configuration using functional options.
type githubissueOption func(*GitHubIssueMutation)

// newGitHubIssueMutation creates new mutation for the GitHubIssue entity.
func newGitHubIssueMutation(c config, op Op, opts ...githubissueOption) *GitHubIssueMutation {
	m := &GitHubIssueMutation{
		config:        c,
		op:            op,
		typ:           TypeGitHubIssue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGitHubIssueID sets the ID field of the mutation.
func withGitHubIssueID(id int) githubissueOption {
	return func(m *GitHubIssueMutation) {
		var (
			err   error
			once  sync.Once
			value *GitHubIssue
		)
		m.oldValue = func(ctx context.Context) (*GitHubIssue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GitHubIssue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGitHubIssue sets the old GitHubIssue of the mutation.
func withGitHubIssue(node *GitHubIssue) githubissueOption {
	return func(m *GitHubIssueMutation) {
		m.oldValue = func(context.Context) (*GitHubIssue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GitHubIssueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GitHubIssueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GitHubIssueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGithubID sets the "github_id" field.
func (m *GitHubIssueMutation) SetGithubID(i int) {
	m.github_id = &i
	m.addgithub_id = nil
}

// GithubID returns the value of the "github_id" field in the mutation.
func (m *GitHubIssueMutation) GithubID() (r int, exists bool) {
	v := m.github_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubID returns the old "github_id" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldGithubID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGithubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGithubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubID: %w", err)
	}
	return oldValue.GithubID, nil
}

// AddGithubID adds i to the "github_id" field.
func (m *GitHubIssueMutation) AddGithubID(i int) {
	if m.addgithub_id != nil {
		*m.addgithub_id += i
	} else {
		m.addgithub_id = &i
	}
}

// AddedGithubID returns the value that was added to the "github_id" field in this mutation.
func (m *GitHubIssueMutation) AddedGithubID() (r int, exists bool) {
	v := m.addgithub_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGithubID resets all changes to the "github_id" field.
func (m *GitHubIssueMutation) ResetGithubID() {
	m.github_id = nil
	m.addgithub_id = nil
}

// SetNumber sets the "number" field.
func (m *GitHubIssueMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *GitHubIssueMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *GitHubIssueMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *GitHubIssueMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *GitHubIssueMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetTitle sets the "title" field.
func (m *GitHubIssueMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GitHubIssueMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *GitHubIssueMutation) ResetTitle() {
	m.title = nil
}

// SetBody sets the "body" field.
func (m *GitHubIssueMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *GitHubIssueMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *GitHubIssueMutation) ResetBody() {
	m.body = nil
}

// SetHTMLURL sets the "html_url" field.
func (m *GitHubIssueMutation) SetHTMLURL(s string) {
	m.html_url = &s
}

// HTMLURL returns the value of the "html_url" field in the mutation.
func (m *GitHubIssueMutation) HTMLURL() (r string, exists bool) {
	v := m.html_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLURL returns the old "html_url" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldHTMLURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHTMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHTMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLURL: %w", err)
	}
	return oldValue.HTMLURL, nil
}

// ResetHTMLURL resets all changes to the "html_url" field.
func (m *GitHubIssueMutation) ResetHTMLURL() {
	m.html_url = nil
}

// SetState sets the "state" field.
func (m *GitHubIssueMutation) SetState(gi githubissue.State) {
	m.state = &gi
}

// State returns the value of the "state" field in the mutation.
func (m *GitHubIssueMutation) State() (r githubissue.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldState(ctx context.Context) (v githubissue.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *GitHubIssueMutation) ResetState() {
	m.state = nil
}

// SetLocked sets the "locked" field.
func (m *GitHubIssueMutation) SetLocked(b bool) {
	m.locked = &b
}

// Locked returns the value of the "locked" field in the mutation.
func (m *GitHubIssueMutation) Locked() (r bool, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldLocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ResetLocked resets all changes to the "locked" field.
func (m *GitHubIssueMutation) ResetLocked() {
	m.locked = nil
}

// SetActiveLockReason sets the "active_lock_reason" field.
func (m *GitHubIssueMutation) SetActiveLockReason(s string) {
	m.active_lock_reason = &s
}

// ActiveLockReason returns the value of the "active_lock_reason" field in the mutation.
func (m *GitHubIssueMutation) ActiveLockReason() (r string, exists bool) {
	v := m.active_lock_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveLockReason returns the old "active_lock_reason" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldActiveLockReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActiveLockReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActiveLockReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveLockReason: %w", err)
	}
	return oldValue.ActiveLockReason, nil
}

// ResetActiveLockReason resets all changes to the "active_lock_reason" field.
func (m *GitHubIssueMutation) ResetActiveLockReason() {
	m.active_lock_reason = nil
}

// SetCommentsCount sets the "comments_count" field.
func (m *GitHubIssueMutation) SetCommentsCount(i int) {
	m.comments_count = &i
	m.addcomments_count = nil
}

// CommentsCount returns the value of the "comments_count" field in the mutation.
func (m *GitHubIssueMutation) CommentsCount() (r int, exists bool) {
	v := m.comments_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentsCount returns the old "comments_count" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldCommentsCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommentsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommentsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentsCount: %w", err)
	}
	return oldValue.CommentsCount, nil
}

// AddCommentsCount adds i to the "comments_count" field.
func (m *GitHubIssueMutation) AddCommentsCount(i int) {
	if m.addcomments_count != nil {
		*m.addcomments_count += i
	} else {
		m.addcomments_count = &i
	}
}

// AddedCommentsCount returns the value that was added to the "comments_count" field in this mutation.
func (m *GitHubIssueMutation) AddedCommentsCount() (r int, exists bool) {
	v := m.addcomments_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentsCount resets all changes to the "comments_count" field.
func (m *GitHubIssueMutation) ResetCommentsCount() {
	m.comments_count = nil
	m.addcomments_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GitHubIssueMutation) SetCreatedAt(s string) {
	m.created_at = &s
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GitHubIssueMutation) CreatedAt() (r string, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldCreatedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GitHubIssueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GitHubIssueMutation) SetUpdatedAt(s string) {
	m.updated_at = &s
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GitHubIssueMutation) UpdatedAt() (r string, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldUpdatedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GitHubIssueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *GitHubIssueMutation) SetClosedAt(s string) {
	m.closed_at = &s
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *GitHubIssueMutation) ClosedAt() (r string, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldClosedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *GitHubIssueMutation) ResetClosedAt() {
	m.closed_at = nil
}

// SetAuthorAssociation sets the "author_association" field.
func (m *GitHubIssueMutation) SetAuthorAssociation(s string) {
	m.author_association = &s
}

// AuthorAssociation returns the value of the "author_association" field in the mutation.
func (m *GitHubIssueMutation) AuthorAssociation() (r string, exists bool) {
	v := m.author_association
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorAssociation returns the old "author_association" field's value of the GitHubIssue entity.
// If the GitHubIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubIssueMutation) OldAuthorAssociation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthorAssociation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthorAssociation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorAssociation: %w", err)
	}
	return oldValue.AuthorAssociation, nil
}

// ResetAuthorAssociation resets all changes to the "author_association" field.
func (m *GitHubIssueMutation) ResetAuthorAssociation() {
	m.author_association = nil
}

// AddAssigneeIDs adds the "assignees" edge to the GitHubUser entity by ids.
func (m *GitHubIssueMutation) AddAssigneeIDs(ids ...int) {
	if m.assignees == nil {
		m.assignees = make(map[int]struct{})
	}
	for i := range ids {
		m.assignees[ids[i]] = struct{}{}
	}
}

// ClearAssignees clears the "assignees" edge to the GitHubUser entity.
func (m *GitHubIssueMutation) ClearAssignees() {
	m.clearedassignees = true
}

// AssigneesCleared reports if the "assignees" edge to the GitHubUser entity was cleared.
func (m *GitHubIssueMutation) AssigneesCleared() bool {
	return m.clearedassignees
}

// RemoveAssigneeIDs removes the "assignees" edge to the GitHubUser entity by IDs.
func (m *GitHubIssueMutation) RemoveAssigneeIDs(ids ...int) {
	if m.removedassignees == nil {
		m.removedassignees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignees, ids[i])
		m.removedassignees[ids[i]] = struct{}{}
	}
}

// RemovedAssignees returns the removed IDs of the "assignees" edge to the GitHubUser entity.
func (m *GitHubIssueMutation) RemovedAssigneesIDs() (ids []int) {
	for id := range m.removedassignees {
		ids = append(ids, id)
	}
	return
}

// AssigneesIDs returns the "assignees" edge IDs in the mutation.
func (m *GitHubIssueMutation) AssigneesIDs() (ids []int) {
	for id := range m.assignees {
		ids = append(ids, id)
	}
	return
}

// ResetAssignees resets all changes to the "assignees" edge.
func (m *GitHubIssueMutation) ResetAssignees() {
	m.assignees = nil
	m.clearedassignees = false
	m.removedassignees = nil
}

// SetAuthorID sets the "author" edge to the GitHubUser entity by id.
func (m *GitHubIssueMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the GitHubUser entity.
func (m *GitHubIssueMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the GitHubUser entity was cleared.
func (m *GitHubIssueMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *GitHubIssueMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *GitHubIssueMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *GitHubIssueMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetClosedByID sets the "closed_by" edge to the GitHubUser entity by id.
func (m *GitHubIssueMutation) SetClosedByID(id int) {
	m.closed_by = &id
}

// ClearClosedBy clears the "closed_by" edge to the GitHubUser entity.
func (m *GitHubIssueMutation) ClearClosedBy() {
	m.clearedclosed_by = true
}

// ClosedByCleared reports if the "closed_by" edge to the GitHubUser entity was cleared.
func (m *GitHubIssueMutation) ClosedByCleared() bool {
	return m.clearedclosed_by
}

// ClosedByID returns the "closed_by" edge ID in the mutation.
func (m *GitHubIssueMutation) ClosedByID() (id int, exists bool) {
	if m.closed_by != nil {
		return *m.closed_by, true
	}
	return
}

// ClosedByIDs returns the "closed_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClosedByID instead. It exists only for internal usage by the builders.
func (m *GitHubIssueMutation) ClosedByIDs() (ids []int) {
	if id := m.closed_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClosedBy resets all changes to the "closed_by" edge.
func (m *GitHubIssueMutation) ResetClosedBy() {
	m.closed_by = nil
	m.clearedclosed_by = false
}

// Where appends a list predicates to the GitHubIssueMutation builder.
func (m *GitHubIssueMutation) Where(ps ...predicate.GitHubIssue) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GitHubIssueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GitHubIssue).
func (m *GitHubIssueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GitHubIssueMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.github_id != nil {
		fields = append(fields, githubissue.FieldGithubID)
	}
	if m.number != nil {
		fields = append(fields, githubissue.FieldNumber)
	}
	if m.title != nil {
		fields = append(fields, githubissue.FieldTitle)
	}
	if m.body != nil {
		fields = append(fields, githubissue.FieldBody)
	}
	if m.html_url != nil {
		fields = append(fields, githubissue.FieldHTMLURL)
	}
	if m.state != nil {
		fields = append(fields, githubissue.FieldState)
	}
	if m.locked != nil {
		fields = append(fields, githubissue.FieldLocked)
	}
	if m.active_lock_reason != nil {
		fields = append(fields, githubissue.FieldActiveLockReason)
	}
	if m.comments_count != nil {
		fields = append(fields, githubissue.FieldCommentsCount)
	}
	if m.created_at != nil {
		fields = append(fields, githubissue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, githubissue.FieldUpdatedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, githubissue.FieldClosedAt)
	}
	if m.author_association != nil {
		fields = append(fields, githubissue.FieldAuthorAssociation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GitHubIssueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case githubissue.FieldGithubID:
		return m.GithubID()
	case githubissue.FieldNumber:
		return m.Number()
	case githubissue.FieldTitle:
		return m.Title()
	case githubissue.FieldBody:
		return m.Body()
	case githubissue.FieldHTMLURL:
		return m.HTMLURL()
	case githubissue.FieldState:
		return m.State()
	case githubissue.FieldLocked:
		return m.Locked()
	case githubissue.FieldActiveLockReason:
		return m.ActiveLockReason()
	case githubissue.FieldCommentsCount:
		return m.CommentsCount()
	case githubissue.FieldCreatedAt:
		return m.CreatedAt()
	case githubissue.FieldUpdatedAt:
		return m.UpdatedAt()
	case githubissue.FieldClosedAt:
		return m.ClosedAt()
	case githubissue.FieldAuthorAssociation:
		return m.AuthorAssociation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GitHubIssueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case githubissue.FieldGithubID:
		return m.OldGithubID(ctx)
	case githubissue.FieldNumber:
		return m.OldNumber(ctx)
	case githubissue.FieldTitle:
		return m.OldTitle(ctx)
	case githubissue.FieldBody:
		return m.OldBody(ctx)
	case githubissue.FieldHTMLURL:
		return m.OldHTMLURL(ctx)
	case githubissue.FieldState:
		return m.OldState(ctx)
	case githubissue.FieldLocked:
		return m.OldLocked(ctx)
	case githubissue.FieldActiveLockReason:
		return m.OldActiveLockReason(ctx)
	case githubissue.FieldCommentsCount:
		return m.OldCommentsCount(ctx)
	case githubissue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case githubissue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case githubissue.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case githubissue.FieldAuthorAssociation:
		return m.OldAuthorAssociation(ctx)
	}
	return nil, fmt.Errorf("unknown GitHubIssue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitHubIssueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case githubissue.FieldGithubID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubID(v)
		return nil
	case githubissue.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case githubissue.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case githubissue.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case githubissue.FieldHTMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLURL(v)
		return nil
	case githubissue.FieldState:
		v, ok := value.(githubissue.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case githubissue.FieldLocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case githubissue.FieldActiveLockReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveLockReason(v)
		return nil
	case githubissue.FieldCommentsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentsCount(v)
		return nil
	case githubissue.FieldCreatedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case githubissue.FieldUpdatedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case githubissue.FieldClosedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case githubissue.FieldAuthorAssociation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorAssociation(v)
		return nil
	}
	return fmt.Errorf("unknown GitHubIssue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GitHubIssueMutation) AddedFields() []string {
	var fields []string
	if m.addgithub_id != nil {
		fields = append(fields, githubissue.FieldGithubID)
	}
	if m.addnumber != nil {
		fields = append(fields, githubissue.FieldNumber)
	}
	if m.addcomments_count != nil {
		fields = append(fields, githubissue.FieldCommentsCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GitHubIssueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case githubissue.FieldGithubID:
		return m.AddedGithubID()
	case githubissue.FieldNumber:
		return m.AddedNumber()
	case githubissue.FieldCommentsCount:
		return m.AddedCommentsCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitHubIssueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case githubissue.FieldGithubID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGithubID(v)
		return nil
	case githubissue.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case githubissue.FieldCommentsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentsCount(v)
		return nil
	}
	return fmt.Errorf("unknown GitHubIssue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GitHubIssueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GitHubIssueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GitHubIssueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GitHubIssue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GitHubIssueMutation) ResetField(name string) error {
	switch name {
	case githubissue.FieldGithubID:
		m.ResetGithubID()
		return nil
	case githubissue.FieldNumber:
		m.ResetNumber()
		return nil
	case githubissue.FieldTitle:
		m.ResetTitle()
		return nil
	case githubissue.FieldBody:
		m.ResetBody()
		return nil
	case githubissue.FieldHTMLURL:
		m.ResetHTMLURL()
		return nil
	case githubissue.FieldState:
		m.ResetState()
		return nil
	case githubissue.FieldLocked:
		m.ResetLocked()
		return nil
	case githubissue.FieldActiveLockReason:
		m.ResetActiveLockReason()
		return nil
	case githubissue.FieldCommentsCount:
		m.ResetCommentsCount()
		return nil
	case githubissue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case githubissue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case githubissue.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case githubissue.FieldAuthorAssociation:
		m.ResetAuthorAssociation()
		return nil
	}
	return fmt.Errorf("unknown GitHubIssue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GitHubIssueMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.assignees != nil {
		edges = append(edges, githubissue.EdgeAssignees)
	}
	if m.author != nil {
		edges = append(edges, githubissue.EdgeAuthor)
	}
	if m.closed_by != nil {
		edges = append(edges, githubissue.EdgeClosedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GitHubIssueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case githubissue.EdgeAssignees:
		ids := make([]ent.Value, 0, len(m.assignees))
		for id := range m.assignees {
			ids = append(ids, id)
		}
		return ids
	case githubissue.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case githubissue.EdgeClosedBy:
		if id := m.closed_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GitHubIssueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedassignees != nil {
		edges = append(edges, githubissue.EdgeAssignees)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GitHubIssueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case githubissue.EdgeAssignees:
		ids := make([]ent.Value, 0, len(m.removedassignees))
		for id := range m.removedassignees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GitHubIssueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedassignees {
		edges = append(edges, githubissue.EdgeAssignees)
	}
	if m.clearedauthor {
		edges = append(edges, githubissue.EdgeAuthor)
	}
	if m.clearedclosed_by {
		edges = append(edges, githubissue.EdgeClosedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GitHubIssueMutation) EdgeCleared(name string) bool {
	switch name {
	case githubissue.EdgeAssignees:
		return m.clearedassignees
	case githubissue.EdgeAuthor:
		return m.clearedauthor
	case githubissue.EdgeClosedBy:
		return m.clearedclosed_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GitHubIssueMutation) ClearEdge(name string) error {
	switch name {
	case githubissue.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case githubissue.EdgeClosedBy:
		m.ClearClosedBy()
		return nil
	}
	return fmt.Errorf("unknown GitHubIssue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GitHubIssueMutation) ResetEdge(name string) error {
	switch name {
	case githubissue.EdgeAssignees:
		m.ResetAssignees()
		return nil
	case githubissue.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case githubissue.EdgeClosedBy:
		m.ResetClosedBy()
		return nil
	}
	return fmt.Errorf("unknown GitHubIssue edge %s", name)
}

// GitHubUserMutation represents an operation that mutates the GitHubUser nodes in the graph.
type GitHubUserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	github_id              *int
	addgithub_id           *int
	login                  *string
	email                  *string
	name                   *string
	clearedFields          map[string]struct{}
	created_issues         map[int]struct{}
	removedcreated_issues  map[int]struct{}
	clearedcreated_issues  bool
	closed_issues          map[int]struct{}
	removedclosed_issues   map[int]struct{}
	clearedclosed_issues   bool
	person                 *int
	clearedperson          bool
	assigned_issues        map[int]struct{}
	removedassigned_issues map[int]struct{}
	clearedassigned_issues bool
	done                   bool
	oldValue               func(context.Context) (*GitHubUser, error)
	predicates             []predicate.GitHubUser
}

var _ ent.Mutation = (*GitHubUserMutation)(nil)

// githubuserOption allows management of the mutation configuration using functional options.
type githubuserOption func(*GitHubUserMutation)

// newGitHubUserMutation creates new mutation for the GitHubUser entity.
func newGitHubUserMutation(c config, op Op, opts ...githubuserOption) *GitHubUserMutation {
	m := &GitHubUserMutation{
		config:        c,
		op:            op,
		typ:           TypeGitHubUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGitHubUserID sets the ID field of the mutation.
func withGitHubUserID(id int) githubuserOption {
	return func(m *GitHubUserMutation) {
		var (
			err   error
			once  sync.Once
			value *GitHubUser
		)
		m.oldValue = func(ctx context.Context) (*GitHubUser, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GitHubUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGitHubUser sets the old GitHubUser of the mutation.
func withGitHubUser(node *GitHubUser) githubuserOption {
	return func(m *GitHubUserMutation) {
		m.oldValue = func(context.Context) (*GitHubUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GitHubUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GitHubUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GitHubUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGithubID sets the "github_id" field.
func (m *GitHubUserMutation) SetGithubID(i int) {
	m.github_id = &i
	m.addgithub_id = nil
}

// GithubID returns the value of the "github_id" field in the mutation.
func (m *GitHubUserMutation) GithubID() (r int, exists bool) {
	v := m.github_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubID returns the old "github_id" field's value of the GitHubUser entity.
// If the GitHubUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubUserMutation) OldGithubID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGithubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGithubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubID: %w", err)
	}
	return oldValue.GithubID, nil
}

// AddGithubID adds i to the "github_id" field.
func (m *GitHubUserMutation) AddGithubID(i int) {
	if m.addgithub_id != nil {
		*m.addgithub_id += i
	} else {
		m.addgithub_id = &i
	}
}

// AddedGithubID returns the value that was added to the "github_id" field in this mutation.
func (m *GitHubUserMutation) AddedGithubID() (r int, exists bool) {
	v := m.addgithub_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGithubID resets all changes to the "github_id" field.
func (m *GitHubUserMutation) ResetGithubID() {
	m.github_id = nil
	m.addgithub_id = nil
}

// SetLogin sets the "login" field.
func (m *GitHubUserMutation) SetLogin(s string) {
	m.login = &s
}

// Login returns the value of the "login" field in the mutation.
func (m *GitHubUserMutation) Login() (r string, exists bool) {
	v := m.login
	if v == nil {
		return
	}
	return *v, true
}

// OldLogin returns the old "login" field's value of the GitHubUser entity.
// If the GitHubUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubUserMutation) OldLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogin: %w", err)
	}
	return oldValue.Login, nil
}

// ResetLogin resets all changes to the "login" field.
func (m *GitHubUserMutation) ResetLogin() {
	m.login = nil
}

// SetEmail sets the "email" field.
func (m *GitHubUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *GitHubUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the GitHubUser entity.
// If the GitHubUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *GitHubUserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *GitHubUserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GitHubUserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GitHubUser entity.
// If the GitHubUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitHubUserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GitHubUserMutation) ResetName() {
	m.name = nil
}

// AddCreatedIssueIDs adds the "created_issues" edge to the GitHubIssue entity by ids.
func (m *GitHubUserMutation) AddCreatedIssueIDs(ids ...int) {
	if m.created_issues == nil {
		m.created_issues = make(map[int]struct{})
	}
	for i := range ids {
		m.created_issues[ids[i]] = struct{}{}
	}
}

// ClearCreatedIssues clears the "created_issues" edge to the GitHubIssue entity.
func (m *GitHubUserMutation) ClearCreatedIssues() {
	m.clearedcreated_issues = true
}

// CreatedIssuesCleared reports if the "created_issues" edge to the GitHubIssue entity was cleared.
func (m *GitHubUserMutation) CreatedIssuesCleared() bool {
	return m.clearedcreated_issues
}

// RemoveCreatedIssueIDs removes the "created_issues" edge to the GitHubIssue entity by IDs.
func (m *GitHubUserMutation) RemoveCreatedIssueIDs(ids ...int) {
	if m.removedcreated_issues == nil {
		m.removedcreated_issues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_issues, ids[i])
		m.removedcreated_issues[ids[i]] = struct{}{}
	}
}

// RemovedCreatedIssues returns the removed IDs of the "created_issues" edge to the GitHubIssue entity.
func (m *GitHubUserMutation) RemovedCreatedIssuesIDs() (ids []int) {
	for id := range m.removedcreated_issues {
		ids = append(ids, id)
	}
	return
}

// CreatedIssuesIDs returns the "created_issues" edge IDs in the mutation.
func (m *GitHubUserMutation) CreatedIssuesIDs() (ids []int) {
	for id := range m.created_issues {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedIssues resets all changes to the "created_issues" edge.
func (m *GitHubUserMutation) ResetCreatedIssues() {
	m.created_issues = nil
	m.clearedcreated_issues = false
	m.removedcreated_issues = nil
}

// AddClosedIssueIDs adds the "closed_issues" edge to the GitHubIssue entity by ids.
func (m *GitHubUserMutation) AddClosedIssueIDs(ids ...int) {
	if m.closed_issues == nil {
		m.closed_issues = make(map[int]struct{})
	}
	for i := range ids {
		m.closed_issues[ids[i]] = struct{}{}
	}
}

// ClearClosedIssues clears the "closed_issues" edge to the GitHubIssue entity.
func (m *GitHubUserMutation) ClearClosedIssues() {
	m.clearedclosed_issues = true
}

// ClosedIssuesCleared reports if the "closed_issues" edge to the GitHubIssue entity was cleared.
func (m *GitHubUserMutation) ClosedIssuesCleared() bool {
	return m.clearedclosed_issues
}

// RemoveClosedIssueIDs removes the "closed_issues" edge to the GitHubIssue entity by IDs.
func (m *GitHubUserMutation) RemoveClosedIssueIDs(ids ...int) {
	if m.removedclosed_issues == nil {
		m.removedclosed_issues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.closed_issues, ids[i])
		m.removedclosed_issues[ids[i]] = struct{}{}
	}
}

// RemovedClosedIssues returns the removed IDs of the "closed_issues" edge to the GitHubIssue entity.
func (m *GitHubUserMutation) RemovedClosedIssuesIDs() (ids []int) {
	for id := range m.removedclosed_issues {
		ids = append(ids, id)
	}
	return
}

// ClosedIssuesIDs returns the "closed_issues" edge IDs in the mutation.
func (m *GitHubUserMutation) ClosedIssuesIDs() (ids []int) {
	for id := range m.closed_issues {
		ids = append(ids, id)
	}
	return
}

// ResetClosedIssues resets all changes to the "closed_issues" edge.
func (m *GitHubUserMutation) ResetClosedIssues() {
	m.closed_issues = nil
	m.clearedclosed_issues = false
	m.removedclosed_issues = nil
}

// SetPersonID sets the "person" edge to the Person entity by id.
func (m *GitHubUserMutation) SetPersonID(id int) {
	m.person = &id
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *GitHubUserMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *GitHubUserMutation) PersonCleared() bool {
	return m.clearedperson
}

// PersonID returns the "person" edge ID in the mutation.
func (m *GitHubUserMutation) PersonID() (id int, exists bool) {
	if m.person != nil {
		return *m.person, true
	}
	return
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *GitHubUserMutation) PersonIDs() (ids []int) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *GitHubUserMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// AddAssignedIssueIDs adds the "assigned_issues" edge to the GitHubIssue entity by ids.
func (m *GitHubUserMutation) AddAssignedIssueIDs(ids ...int) {
	if m.assigned_issues == nil {
		m.assigned_issues = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_issues[ids[i]] = struct{}{}
	}
}

// ClearAssignedIssues clears the "assigned_issues" edge to the GitHubIssue entity.
func (m *GitHubUserMutation) ClearAssignedIssues() {
	m.clearedassigned_issues = true
}

// AssignedIssuesCleared reports if the "assigned_issues" edge to the GitHubIssue entity was cleared.
func (m *GitHubUserMutation) AssignedIssuesCleared() bool {
	return m.clearedassigned_issues
}

// RemoveAssignedIssueIDs removes the "assigned_issues" edge to the GitHubIssue entity by IDs.
func (m *GitHubUserMutation) RemoveAssignedIssueIDs(ids ...int) {
	if m.removedassigned_issues == nil {
		m.removedassigned_issues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assigned_issues, ids[i])
		m.removedassigned_issues[ids[i]] = struct{}{}
	}
}

// RemovedAssignedIssues returns the removed IDs of the "assigned_issues" edge to the GitHubIssue entity.
func (m *GitHubUserMutation) RemovedAssignedIssuesIDs() (ids []int) {
	for id := range m.removedassigned_issues {
		ids = append(ids, id)
	}
	return
}

// AssignedIssuesIDs returns the "assigned_issues" edge IDs in the mutation.
func (m *GitHubUserMutation) AssignedIssuesIDs() (ids []int) {
	for id := range m.assigned_issues {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedIssues resets all changes to the "assigned_issues" edge.
func (m *GitHubUserMutation) ResetAssignedIssues() {
	m.assigned_issues = nil
	m.clearedassigned_issues = false
	m.removedassigned_issues = nil
}

// Where appends a list predicates to the GitHubUserMutation builder.
func (m *GitHubUserMutation) Where(ps ...predicate.GitHubUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GitHubUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GitHubUser).
func (m *GitHubUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GitHubUserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.github_id != nil {
		fields = append(fields, githubuser.FieldGithubID)
	}
	if m.login != nil {
		fields = append(fields, githubuser.FieldLogin)
	}
	if m.email != nil {
		fields = append(fields, githubuser.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, githubuser.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GitHubUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case githubuser.FieldGithubID:
		return m.GithubID()
	case githubuser.FieldLogin:
		return m.Login()
	case githubuser.FieldEmail:
		return m.Email()
	case githubuser.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GitHubUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case githubuser.FieldGithubID:
		return m.OldGithubID(ctx)
	case githubuser.FieldLogin:
		return m.OldLogin(ctx)
	case githubuser.FieldEmail:
		return m.OldEmail(ctx)
	case githubuser.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown GitHubUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitHubUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case githubuser.FieldGithubID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubID(v)
		return nil
	case githubuser.FieldLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogin(v)
		return nil
	case githubuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case githubuser.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown GitHubUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GitHubUserMutation) AddedFields() []string {
	var fields []string
	if m.addgithub_id != nil {
		fields = append(fields, githubuser.FieldGithubID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GitHubUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case githubuser.FieldGithubID:
		return m.AddedGithubID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitHubUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case githubuser.FieldGithubID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGithubID(v)
		return nil
	}
	return fmt.Errorf("unknown GitHubUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GitHubUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GitHubUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GitHubUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GitHubUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GitHubUserMutation) ResetField(name string) error {
	switch name {
	case githubuser.FieldGithubID:
		m.ResetGithubID()
		return nil
	case githubuser.FieldLogin:
		m.ResetLogin()
		return nil
	case githubuser.FieldEmail:
		m.ResetEmail()
		return nil
	case githubuser.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown GitHubUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GitHubUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.created_issues != nil {
		edges = append(edges, githubuser.EdgeCreatedIssues)
	}
	if m.closed_issues != nil {
		edges = append(edges, githubuser.EdgeClosedIssues)
	}
	if m.person != nil {
		edges = append(edges, githubuser.EdgePerson)
	}
	if m.assigned_issues != nil {
		edges = append(edges, githubuser.EdgeAssignedIssues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GitHubUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case githubuser.EdgeCreatedIssues:
		ids := make([]ent.Value, 0, len(m.created_issues))
		for id := range m.created_issues {
			ids = append(ids, id)
		}
		return ids
	case githubuser.EdgeClosedIssues:
		ids := make([]ent.Value, 0, len(m.closed_issues))
		for id := range m.closed_issues {
			ids = append(ids, id)
		}
		return ids
	case githubuser.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	case githubuser.EdgeAssignedIssues:
		ids := make([]ent.Value, 0, len(m.assigned_issues))
		for id := range m.assigned_issues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GitHubUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcreated_issues != nil {
		edges = append(edges, githubuser.EdgeCreatedIssues)
	}
	if m.removedclosed_issues != nil {
		edges = append(edges, githubuser.EdgeClosedIssues)
	}
	if m.removedassigned_issues != nil {
		edges = append(edges, githubuser.EdgeAssignedIssues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GitHubUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case githubuser.EdgeCreatedIssues:
		ids := make([]ent.Value, 0, len(m.removedcreated_issues))
		for id := range m.removedcreated_issues {
			ids = append(ids, id)
		}
		return ids
	case githubuser.EdgeClosedIssues:
		ids := make([]ent.Value, 0, len(m.removedclosed_issues))
		for id := range m.removedclosed_issues {
			ids = append(ids, id)
		}
		return ids
	case githubuser.EdgeAssignedIssues:
		ids := make([]ent.Value, 0, len(m.removedassigned_issues))
		for id := range m.removedassigned_issues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GitHubUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreated_issues {
		edges = append(edges, githubuser.EdgeCreatedIssues)
	}
	if m.clearedclosed_issues {
		edges = append(edges, githubuser.EdgeClosedIssues)
	}
	if m.clearedperson {
		edges = append(edges, githubuser.EdgePerson)
	}
	if m.clearedassigned_issues {
		edges = append(edges, githubuser.EdgeAssignedIssues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GitHubUserMutation) EdgeCleared(name string) bool {
	switch name {
	case githubuser.EdgeCreatedIssues:
		return m.clearedcreated_issues
	case githubuser.EdgeClosedIssues:
		return m.clearedclosed_issues
	case githubuser.EdgePerson:
		return m.clearedperson
	case githubuser.EdgeAssignedIssues:
		return m.clearedassigned_issues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GitHubUserMutation) ClearEdge(name string) error {
	switch name {
	case githubuser.EdgePerson:
		m.ClearPerson()
		return nil
	}
	return fmt.Errorf("unknown GitHubUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GitHubUserMutation) ResetEdge(name string) error {
	switch name {
	case githubuser.EdgeCreatedIssues:
		m.ResetCreatedIssues()
		return nil
	case githubuser.EdgeClosedIssues:
		m.ResetClosedIssues()
		return nil
	case githubuser.EdgePerson:
		m.ResetPerson()
		return nil
	case githubuser.EdgeAssignedIssues:
		m.ResetAssignedIssues()
		return nil
	}
	return fmt.Errorf("unknown GitHubUser edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	email                 *string
	name                  *string
	isGiantSwarmEmployee  *bool
	clearedFields         map[string]struct{}
	github_account        *int
	clearedgithub_account bool
	done                  bool
	oldValue              func(context.Context) (*Person, error)
	predicates            []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id int) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *PersonMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PersonMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *PersonMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *PersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonMutation) ResetName() {
	m.name = nil
}

// SetIsGiantSwarmEmployee sets the "isGiantSwarmEmployee" field.
func (m *PersonMutation) SetIsGiantSwarmEmployee(b bool) {
	m.isGiantSwarmEmployee = &b
}

// IsGiantSwarmEmployee returns the value of the "isGiantSwarmEmployee" field in the mutation.
func (m *PersonMutation) IsGiantSwarmEmployee() (r bool, exists bool) {
	v := m.isGiantSwarmEmployee
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGiantSwarmEmployee returns the old "isGiantSwarmEmployee" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIsGiantSwarmEmployee(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsGiantSwarmEmployee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsGiantSwarmEmployee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGiantSwarmEmployee: %w", err)
	}
	return oldValue.IsGiantSwarmEmployee, nil
}

// ResetIsGiantSwarmEmployee resets all changes to the "isGiantSwarmEmployee" field.
func (m *PersonMutation) ResetIsGiantSwarmEmployee() {
	m.isGiantSwarmEmployee = nil
}

// SetGithubAccountID sets the "github_account" edge to the GitHubUser entity by id.
func (m *PersonMutation) SetGithubAccountID(id int) {
	m.github_account = &id
}

// ClearGithubAccount clears the "github_account" edge to the GitHubUser entity.
func (m *PersonMutation) ClearGithubAccount() {
	m.clearedgithub_account = true
}

// GithubAccountCleared reports if the "github_account" edge to the GitHubUser entity was cleared.
func (m *PersonMutation) GithubAccountCleared() bool {
	return m.clearedgithub_account
}

// GithubAccountID returns the "github_account" edge ID in the mutation.
func (m *PersonMutation) GithubAccountID() (id int, exists bool) {
	if m.github_account != nil {
		return *m.github_account, true
	}
	return
}

// GithubAccountIDs returns the "github_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GithubAccountID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) GithubAccountIDs() (ids []int) {
	if id := m.github_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGithubAccount resets all changes to the "github_account" edge.
func (m *PersonMutation) ResetGithubAccount() {
	m.github_account = nil
	m.clearedgithub_account = false
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, person.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, person.FieldName)
	}
	if m.isGiantSwarmEmployee != nil {
		fields = append(fields, person.FieldIsGiantSwarmEmployee)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldEmail:
		return m.Email()
	case person.FieldName:
		return m.Name()
	case person.FieldIsGiantSwarmEmployee:
		return m.IsGiantSwarmEmployee()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldEmail:
		return m.OldEmail(ctx)
	case person.FieldName:
		return m.OldName(ctx)
	case person.FieldIsGiantSwarmEmployee:
		return m.OldIsGiantSwarmEmployee(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case person.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case person.FieldIsGiantSwarmEmployee:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGiantSwarmEmployee(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldEmail:
		m.ResetEmail()
		return nil
	case person.FieldName:
		m.ResetName()
		return nil
	case person.FieldIsGiantSwarmEmployee:
		m.ResetIsGiantSwarmEmployee()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.github_account != nil {
		edges = append(edges, person.EdgeGithubAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeGithubAccount:
		if id := m.github_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgithub_account {
		edges = append(edges, person.EdgeGithubAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeGithubAccount:
		return m.clearedgithub_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	case person.EdgeGithubAccount:
		m.ClearGithubAccount()
		return nil
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeGithubAccount:
		m.ResetGithubAccount()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

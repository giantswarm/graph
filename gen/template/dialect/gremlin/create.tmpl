{{/*
Copyright 2019-present Facebook Inc. All rights reserved.
This source code is licensed under the Apache 2.0 license found
in the LICENSE file in the root directory of this source tree.
*/}}

{{/* gotype: entgo.io/ent/entc/gen.typeScope */}}

{{ define "dialect/gremlin/create" }}
{{ $builder := pascal $.Scope.Builder }}
{{ $receiver := receiver $builder }}
{{ $mutation := print $receiver ".mutation"  }}

func ({{ $receiver }} *{{ $builder }}) gremlinSave(ctx context.Context) (*{{ $.Name }}, error) {
	res := &gremlin.Response{}
	query, bindings := {{ $receiver }}.gremlin().Query()
	if err := {{ $receiver }}.driver.Exec(ctx, query, bindings, res); err != nil {
		return nil, err
	}
	if err, ok := isConstantError(res); ok {
		return nil, err
	}
	{{ $.Receiver }} := &{{ $.Name }}{config: {{ $receiver }}.config}
	if err := {{ $.Receiver }}.FromResponse(res); err != nil {
		return nil, err
	}
	return {{ $.Receiver }}, nil
}

func ({{ $receiver }} *{{ $builder }}) gremlin() *dsl.Traversal {
	type constraint struct {
		firstQueryPred *dsl.Traversal // constraint predicate.
		pred           *dsl.Traversal // constraint predicate.
		test           *dsl.Traversal // test matches and its constant.
	}
	constraints := make([]*constraint, 0, {{ .NumConstraint }})
	createTraversal := func(constraints []*constraint, traversalFuncs []func(*dsl.Traversal)) *dsl.Traversal {
		var v *dsl.Traversal
		if len(constraints) > 0 {
			// We will use coalesce, therefore AddV will be child traversal, so we need __ here
			v = __.New().AddV({{ $.Package }}.Label)
		} else {
			v = g.AddV({{ $.Package }}.Label)
		}
		for _, tf := range traversalFuncs {
			tf(v)
		}
		return v
	}
	traversalFuncs := []func(*dsl.Traversal){}
	{{- if $.ID.UserDefined }}
		if id, ok := {{ $mutation }}.{{ $.ID.MutationGet }}(); ok {
			traversalFuncs = append(traversalFuncs, func(v *dsl.Traversal) {
				v.Property(dsl.ID, id)
			})
		}
	{{- end }}
	{{- range $i, $f := $.MutationFields }}
		if value, ok := {{ $mutation }}.{{ $f.MutationGet }}(); ok {
			{{- if $f.Unique }}
				constraints = append(constraints, &constraint{
					firstQueryPred: g.V().Has({{ $.Package }}.Label, {{ $.Package }}.{{ $f.Constant }}, value).Count(),
					pred: __.V().Has({{ $.Package }}.Label, {{ $.Package }}.{{ $f.Constant }}, value).Count(),
					test: __.Is(p.NEQ(0)).Constant(NewErrUniqueField({{ $.Package }}.Label, {{ $.Package }}.{{ $f.Constant }}, value)),
				})
			{{- end }}
			traversalFuncs = append(traversalFuncs, func(v *dsl.Traversal) {
				v.Property(dsl.Single, {{ $.Package }}.{{ $f.Constant }}, value)
			})
		}
	{{- end }}
	{{- range $e := $.Edges }}
		{{- $direction := "In" }}
		{{- $name := printf "%s.%s" $.Package $e.LabelConstant }}
		for _, id := range {{ $mutation }}.{{ $e.StructField }}IDs() {
			{{- if $e.IsInverse }}
				{{- $direction = "Out" }}
				{{- $name = printf "%s.%s" $e.Type.Package $e.LabelConstant }}
				traversalFuncs = append(traversalFuncs, func(v *dsl.Traversal) {
					v.AddE({{ $name }}).From(g.V(id)).InV()
				})
			{{- else }}
				traversalFuncs = append(traversalFuncs, func(v *dsl.Traversal) {
					v.AddE({{ $name }}).To(g.V(id)).OutV()
				})
			{{- end }}
			{{- if $e.HasConstraint }}
				constraints = append(constraints, &constraint{
					pred: g.E().HasLabel({{ $name }}).{{ $direction }}V().HasID(id).Count(),
					test: __.Is(p.NEQ(0)).Constant(NewErrUniqueEdge({{ $.Package }}.Label, {{ $name }}, string(id))),
				})
			{{- end }}
		}
	{{- end }}
	v := createTraversal(constraints, traversalFuncs)
	{{- with .NumConstraint }}
		if len(constraints) == 0 {
			return v.ValueMap(true)
		}
		var tr *dsl.Traversal
		if len(constraints) == 1 {
			// use the TraversalSource (g) to start the traversal
			tr = constraints[0].firstQueryPred.Coalesce(constraints[0].test, v.ValueMap(true))
		} else {
			// use the __ class rather than a TraversalSource to construct the child traversal anonymously
			tr = constraints[0].pred.Coalesce(constraints[0].test, v.ValueMap(true))
		}
		for i, cr := range constraints[1:] {
			if i == len(constraints[1:]) - 1 && cr.firstQueryPred != nil {
				// use the TraversalSource (g) to start the traversal
				tr = cr.firstQueryPred.Coalesce(cr.test, tr)
			} else {
				// use the __ class rather than a TraversalSource to construct the child traversal anonymously
				tr = cr.pred.Coalesce(cr.test, tr)
			}
		}
		return tr
	{{- else }}
		return v.ValueMap(true)
	{{- end }}
}
{{ end }}
